#!/usr/bin/env bash

source "$extension_scripts_path/initialize"

# TODO:
#
#   * Crank up the verbosity on errors
#
# This will run any deploy hooks that are called
#   (by hook file name)
# Hooks are sourced into a subshell IF they are executable.
# This means that users may disable hooks by changing their
# execute bit.
#
hook()
{
  hook="$1"
  true ${hooks_flag:=1}
  [[ ${hooks_flag:-1} -eq 0 ]] && return 0 # Return if hooks flag is set to false

  # Server
  if [[ -s "$shared_path/deploy/$hook" ]] ; then
    ( source "$shared_path/deploy/$hook" )
  fi

  # Server, Environment specific
  if [[ -n "${environment:-""}" && -x "$shared_path/deploy/#{$environment}/$hook" ]] ; then
    ( source "$shared_path/deploy/#{$environment}/$hook" )
  fi

  # Project
  if [[ -d "$shared_path/$project" && -x "$shared_path/$project/config/deploy/$hook" ]] ; then
    ( source "$shared_path/$project/config/deploy/$hook" )
  fi

  # Project, Environment specific
  if [[ -n "${environment:-""}" && -x "$shared_path/$project/config/deploy/$environment/$hook" ]] ; then
    ( source "$shared_path/project/config/deploy/$environment/$hook" )
  fi
}

update()
{
  update_repository && replace_current

  return $?
}

update_repository()
{
  log "Updating local repository in $shared_path/$project."

  pushd "$shared_path/$project" > /dev/null 2>&1

  case "$scm" in

    git)
      git checkout master -f -q

      # There should be *no* changes to the pristine repo.
      git reset --hard HEAD 2>/dev/null

      #current_branch=$(git branch | awk '/\* /{print $2}')
      log "Pulling updates from $remote"
      git fetch $remote

      log "Switching to branch $branch"
      if ! git branch | awk "/$branch$/" >/dev/null 2>&1 ; then

        git checkout -b $branch --track $remote/$branch 2>/dev/null

      elif ! git branch | awk "/\* $branch$/" >/dev/null 2>&1 ; then

        if ! git checkout $branch 2>/dev/null ; then
          log "ERROR: Branch $remote/$branch not found. Skipping remainder of update."
          return 1
        fi
      else
        log "Already on branch '$branch'."
      fi

      git pull

      if [[ -f .gitmodules ]] ; then
        log "Updating submodules."
        git submodule init 2>/dev/null
        git submodule update
      fi

      if [[ -n "$revision" ]] ; then
        log "Checking out revision '$revision'."
        git checkout $revision >/dev/null 2>&1
      fi

      ;;

    hg)
      log "Pulling from remote"
      hg pull

      if [[ -n "$revision" ]] ; then
        # TODO: Find out if this is how it's done for hg ;)
        log "Checking out revision '$revision'."
        hg update $branch $revision
      else
        log "Updating branch '$branch'."
        hg update $branch
      fi
      ;;

    svn)
      # TODO: specific revision / branch handling
      log "Updating repository"
      svn update
      if [[ "$revision" -gt 0 ]] ; then
        log "Checking out revision $revision"
        svn checkout -r $revision
      fi

      ;;
    *)
      fail "No scm specified found (git,hg,svn)"
      ;;

  esac

  popd > /dev/null 2>&1
}

stage_current()
{
  log "Staging new release to $stage_path"

  rsync -ag --exclude=".${scm}/" \
    "$shared_path/$project/" "$stage_path"

  ensure_paths_exist "$stage_path/public"
}

replace_current()
{
  log "Replacing $current_path from $stage_path"
  if [[ -d "$current_path" ]] ; then
    log "Moving aside previous release."
    ensure_paths_exist "$project_path/previous"
    mv "$current_path" "$project_path/previous/$timestamp"
  else
    log "Current directory does not exist, not removing."
  fi

  mv "$stage_path" "$current_path"

  return $?
}

configure()
{
  if [[ ! -d "$shared_path/config" ]] ; then
    log "No shared config path found, skipping."
    return 0
  else
    ensure_paths_exist "$stage_path/config"
  fi

  local item config_item

  builtin cd "$shared_path/config"

  log "Setting up persistent config files:"
  for config_item in "$shared_path"/config/* ; do
    item=$(basename "$config_item")
    log " - $item"
    rm -rf "$stage_path/config/$item"
    ln -nfs "$shared_path/config/$item" "$stage_path/config/$item"
  done
}

symlink()
{
  log "Setting up persistent directories"

  for dir in tmp log pids files ; do
    if [[ -d "$shared_path/$dir" ]] ; then
      log " - $dir"
      rm -rf "$stage_path/$dir"
      ln -nfs "$shared_path/$dir" "$stage_path/$dir"
    fi
  done

  for dir in $(ls -A "$shared_path/public/") ; do
    if [[ -n "$dir" ]] ; then
      log " - public/$dir"
      rm -rf "$stage_path/public/$dir"
      ln -nfs "$shared_path/public/$dir" "$stage_path/public/$dir"
    fi
  done
}

cleanup()
{
  ensure_paths_exist "$project_path/previous"

  if [[ -n "$old_releases" ]] ; then
    (
    log "Removing old releases..."

    builtin cd "$project_path/previous"

    for release in $(echo $old_releases) ; do
      if [[ -d "$release" ]] ; then
        log " - $release"
        rm -rf $release
      else
        log "Skipping ~/previous/$release as the directory does not exist."
      fi
    done
    )
  fi
}

record()
{
  # TODO: What else could we record that would be useful?
  cd "$shared_path/$project"

  revision=$(git log --no-color -1 | head -n 1 | cut -c 7-47)
  branch=$(git branch --no-color | awk '/^* /{print $2}')

  echo "$revision" >> "$current_path/revision"
  echo "$branch"   >> "$current_path/branch"

  return 0
}

detect_scm()
{
  if [[ -z "$scm" ]] ; then
    if [[ -d "$shared_path/$project/.git" ]] ; then
      scm="git"
    elif [[ -d "$shared_path/$project/.svn" ]] ; then
      scm="svn"
    elif [[ -d "$shared_path/$project/.hg" ]] ; then
      scm="hg"
    fi
  fi
  return 0
}

detect_scm

log "Deploying..."
(
  hook "before_update_repository"
  update_repository
  hook "after_update_repository"

  hook "before_deploy"

  hook "before_stage"
  stage_current
  hook "after_stage"

  hook "before_configure"
  configure
  hook "after_configure"

  hook "before_symlink"
  symlink
  hook "after_symlink"

  hook "before_replace_current"
  replace_current
  hook "after_replace_current"

  hook "before_cleanup"
  cleanup
  hook "after_cleanup"

  hook "before_record"
  record
  hook "after_record"

  hook "after_deploy"
)
result=$?

log "Deploy started at $timestamp and completed at $(date +%m.%d.%Y-%H:%M:%S)"

exit $result
